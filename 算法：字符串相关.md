# 字符串转数字，数字转字符串API

**字符串转数字**

- atoi：参数const char *，atoi要想将string转成整数，需要使用c_str函数将string转换成const char *
- stoi：参数string或const char *

```cpp
//字符串转数字
string str("1234");
int n1 = stoi(str);
int n2 = atoi(str.c_str());

const char * str2 = "1234";
int n3 = stoi(str2);
int n4 = atoi(str2);
```

**数字转字符串**

- to_string：参数int

```cpp
//数字转字符串函数
string str = to_string(123);
```

# 划分字符串

```cpp
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，
同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
输入：aabccggw
切割结果：aa b cc gg w
输出：2 1 2 2 1

aabcacggw
aabcac gg w
6 2 1

aabacbcggw
aabacbc gg w
7 2 1
```

**我的思路：**

- 从末尾开始遍历，把每个字符的最后出现的下标用哈希表存起来
- 再从前往后遍历，确定第一个字符，然后确定结尾下标，再在这中间看有没有其他字符下标比结尾大的

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

vector<int> Partition(string & str)
{
    if(str.empty()) return vector<int>();
    vector<int> result;

    //从末尾开始遍历，把每个字符的最后出现的下标用哈希表存起来
    unordered_map<char, int> map;
    int size = str.size();
    for(int i = size-1; i >= 0; --i)
    {
        if(map.find(str[i]) == map.end())
        {
            map.insert({str[i], i});
        }
    }

    //从前往后遍历，确定第一个字符，然后确定结尾下标，再在这中间看有没有其他字符下标比结尾大的
    for(int i = 0; i < size; ++i)
    {
        int j = map[str[i]];
        for(int k = i + 1; k <= j; ++k)
        {
            if(map[str[k]] >= j)
            {
                j = map[str[k]];
            }
        }
        result.push_back(j-i+1);
        i = j;
    }

    return result;
}

int main(int argc, char* argv[])
{
    string str(argv[1]);
    vector<int> vec = Partition(str);

    for(auto & val : vec)
    {
        cout<<val<<"  ";
    }
    cout<<endl;
}
```

![image-20210520210912751](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3.img/image-20210520210912751.png)

# 字符串变形

```cpp
对于一个给定的字符串，我们需要在线性(也就是O(n))的时间里对它做一些变形。首先这个字符串中包含着一些空格，就像"Hello World"一样，然后我们要做的是把着个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。比如"Hello World"变形后就变成了"wORLD hELLO"。
    
输入："Hello World"
输出："wORLD hELLO"
```

**我的思路：**

- 确定每一个单词的起始结尾下标，反序单词内部，同时转变大小写，A 65 a 97
- 最后整个字符串逆置
- <img src="img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3.img/image-20210522150013715.png" alt="image-20210522150013715" style="zoom:50%;" />

```cpp
//反转单词内部，最后整个逆置
//This is a sample  
//SIHt SI A ELPMAS
//SAMPLE A IS tHIS
class Solution {
public:
    string trans(string s, int n) 
    {
        //确定每一个单词的起始结尾下标，反序，同时转变大小写，A 65 a 97
        for(int i = 0; i < s.size(); ++i)
        {
            int start = i;
            while(s[i] != ' ' && i < s.size())
            {
                if(s[i] >= 'A' && s[i] <= 'Z')    s[i] = 'a' + s[i] - 'A';
                else if(s[i] >= 'a' && s[i] <= 'z')    s[i] = 'A' + s[i] - 'a';
                ++i;
            }
            
            //反转start 到i-1之间
            trans(s, start, i-1);
        }
        
        //最后整个逆置
        reverse(s.begin(), s.end());
        return s;
    }
    
    //反转字符串start到end之间
    void trans(string & s, int start, int end)
    {
        while(start <= end)
        {
            char tmp = s[start];
            s[start] = s[end];
            s[end] = tmp;
            start++;
            end--;
        }
    }
};
```

# 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```cpp
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**我的思路：**

- 假设第一个字符串就是最长公共前缀
- 遍历每个字符串，进行比对，每次更新最长公共前缀

```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) 
    {
        //假设第一个字符串就是最长公共前缀
        //遍历每个字符串，进行比对，每次更新最长公共前缀
        if(strs.empty())    return string("");
        string com = strs.front();
        
        for(int i = 0; i < strs.size(); ++i)
        {
            string tmp;
            for(int j = 0; j < com.size() && j < strs[i].size(); ++j)
            {
                if(com[j] == strs[i][j])
                {
                    tmp += com[j];
                }
                else    break;
            }
            com = tmp;
        }
        return com;
    }
};
```

# 数字翻译成字符串

```cpp
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

输入: 12258
    
输出: 5
    
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

**我的思路：**

- 动态规划：12258的种数 = b2258的种数 + m258的种数
- 先把数字转换成字符串，然后从0下标开始，看该字符串第一个字符和下一个字符组合成的数字是否小于等于25，是的话把这两种情况加起来，不是的话，下标后移
- 用dp数组来作记忆化存储，节省时间

```cpp
class Solution {
public:
    int translateNum(int num) 
    {
        string str = to_string(num);

        //12258 = b2258 + m258
        vector<int> dp(str.size()+1, 0);
        return fun(str, 0, dp);
    }

    int fun(string & str, int index, vector<int> & dp)
    {
        if(index >= str.size()-1)   return 1;  //注意是>=，若是==数组越界
        if(dp[index] != 0)  return dp[index];

        string tmp;
        tmp.push_back(str[index]);
        tmp.push_back(str[index+1]);
        int t = atoi(tmp.c_str());

        if(t <= 25 && tmp[0] != '0')     //注意06不能算2种
        {
            dp[index] = fun(str, index+1, dp) + fun(str, index + 2, dp);
            
        }
        else    
        {
            dp[index] = fun(str, index+1, dp);
        }
        return dp[index];
    }
};
```

# 替换空格

```cpp
请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

输入：s = "We are happy."
输出："We%20are%20happy."
```

**我的思路1：**

- C语言：数出总共有多少个空格，然后开辟新数组空间，从尾部到头去拷贝新数组，遇到空格就补%20

```cpp
char* replaceSpace(char* s){
    // 数出总共有多少个空格，然后从尾部到头部去拷贝新数组
    int count = 0;
    for(int i = 0; s[i] != '\0'; ++i) {
        if(s[i] == ' ') count++;
    }
    
    char * p = (char*)malloc(sizeof(char) * (strlen(s) + 2 * count + 1));
    int j = strlen(s) + 2 * count;

    for(int i = strlen(s); i >= 0; --i) {
        if(s[i] != ' ') {
            p[j--] = s[i];
        } else {
            p[j--] = '0';
            p[j--] = '2';
            p[j--] = '%';
        }
    }
    return p;
}
```

**我的思路2：**

- C++string特性：直接拷贝新字符串，遇到空格就加%20，否则直接拷贝

```cpp
string replaceSpace(string s) {
    string s2;
    for(auto & c : s) {
        if(c == ' ') {
            s2 += "%20";
        } else {
            s2 += c;
        }
    }
    return s2;
}
```

# 字符串压缩（简单）

```cpp
字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

 输入："aabcccccaaa"
 输出："a2b1c5a3"

 输入："abbccd"
 输出："abbccd"
 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
```

**我的思路：**

- 遍历字符串，判断后面字符是否和当前字符相等，相等：当前字符计数器+1
- 不相等：当前字符计数器结束；

```cpp
class Solution {
public:
    string IntToStr(int num) {
        //123->'1','2','3'->"123"
        int tmp = num;
        string rt;
        while(tmp != 0) {
            int a = tmp%10;
            rt.push_back('0'+a);
            tmp/=10;
        }
        reverse(rt.begin(), rt.end());
        return rt;
    }
    string compressString(string S) {
        // 遍历字符串，判断后面字符是否和当前字符相等，相等：当前字符计数器+1
        // 不相等：当前字符计数器结束；
        int size = S.size();
        string rt;
        for(int i = 0; i < size; ++i) {
            int c = 1;
            while(i+1 < size && S[i] == S[i+1]) {
                c++;
                i++;
            } 
            rt.push_back(S[i]);
            // int转string
            string cc = IntToStr(c);
            rt += cc;  //  
        }

        if(rt.size() >= size) {
            return S;
        }
        return rt; 
    }
};
```

# 压缩字符串（中等）

```cpp
给你一个字符数组 chars ，请使用下述算法压缩：

从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：

如果这一组长度为 1 ，则将字符追加到 s 中。
否则，需要向 s 追加字符，后跟这一组的长度。
压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。

请在 修改完输入数组后 ，返回该数组的新长度。

你必须设计并实现一个只使用常量额外空间的算法来解决此问题。


输入：chars = ["a","a","b","b","c","c","c"]
输出：返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]
解释：
"aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。

输入：chars = ["a"]
输出：返回 1 ，输入数组的前 1 个字符应该是：["a"]
解释：
没有任何字符串被替代。

输入：chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
输出：返回 4 ，输入数组的前 4 个字符应该是：["a","b","1","2"]。
解释：
由于字符 "a" 不重复，所以不会被压缩。"bbbbbbbbbbbb" 被 “b12” 替代。
注意每个数字在数组中都有它自己的位置。
```

和上一简单题[字符串压缩（简单）](#字符串压缩（简单）)主要区别：

- 传参类型由string改为vector<char>，1个字符不需要追加数字1
- 空间复杂度要求O(1)
- 结果值存到参数chars中，返回值为新数组结尾长度

**我的思路：**

- 原地压缩：双指针分别标记原串与新串，原串数重复字符个数，用start标记重复字符的起始位置，重复次数=i-start+1；统计重复字符结束时写入新串

```cpp
class Solution {
public:
    int compress(vector<char>& chars) {
        // 原地压缩：双指针分别标记原串与新串，原串数重复字符个数，用start标记重复字符的起始位置，重复次数=i-start+1；重复字符结束时写入新串
        int oldIt = 0;  //原串指针
        int newIt = 0;  //新串指针
        int size = chars.size();

        int start = 0;  //重复字符起始位置

        while(oldIt < size)
        {
            // 统计重复次数
            if(oldIt + 1 < size && chars[oldIt] == chars[oldIt+1])
            {
                oldIt++;
            }
            // 统计结束，将字符写入新串中，次数>1的需要追加次数，<=1的不需要
            else
            {
                if(oldIt - start + 1 > 1)
                {
                    chars[newIt++] = chars[oldIt];
                    string num = to_string(oldIt-start+1);  //12->"12"->push '1', push '2'
                    for(auto & ch : num)
                    {
                        chars[newIt++] = ch;
                    }
                    oldIt++;
                }
                else
                {
                    chars[newIt++] = chars[oldIt++];
                }
                start = oldIt;  //当前字符重复次数统计完毕，下一个字符开始统计
            }
        }
        return newIt;    
    }
};
```

