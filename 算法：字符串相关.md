# 字符串转数字，数字转字符串API

**字符串转数字**

- atoi：参数const char *，atoi要想将string转成整数，需要使用c_str函数将string转换成const char *
- stoi：参数string或const char *

```cpp
//字符串转数字
string str("1234");
int n1 = stoi(str);
int n2 = atoi(str.c_str());

const char * str2 = "1234";
int n3 = stoi(str2);
int n4 = atoi(str2);
```

**数字转字符串**

- to_string：参数int

```cpp
//数字转字符串函数
string str = to_string(123);
```

# 划分字符串

```cpp
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，
同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
输入：aabccggw
切割结果：aa b cc gg w
输出：2 1 2 2 1

aabcacggw
aabcac gg w
6 2 1

aabacbcggw
aabacbc gg w
7 2 1
```

**我的思路：**

- 从末尾开始遍历，把每个字符的最后出现的下标用哈希表存起来
- 再从前往后遍历，确定第一个字符，然后确定结尾下标，再在这中间看有没有其他字符下标比结尾大的

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

vector<int> Partition(string & str)
{
    if(str.empty()) return vector<int>();
    vector<int> result;

    //从末尾开始遍历，把每个字符的最后出现的下标用哈希表存起来
    unordered_map<char, int> map;
    int size = str.size();
    for(int i = size-1; i >= 0; --i)
    {
        if(map.find(str[i]) == map.end())
        {
            map.insert({str[i], i});
        }
    }

    //从前往后遍历，确定第一个字符，然后确定结尾下标，再在这中间看有没有其他字符下标比结尾大的
    for(int i = 0; i < size; ++i)
    {
        int j = map[str[i]];
        for(int k = i + 1; k <= j; ++k)
        {
            if(map[str[k]] >= j)
            {
                j = map[str[k]];
            }
        }
        result.push_back(j-i+1);
        i = j;
    }

    return result;
}

int main(int argc, char* argv[])
{
    string str(argv[1]);
    vector<int> vec = Partition(str);

    for(auto & val : vec)
    {
        cout<<val<<"  ";
    }
    cout<<endl;
}
```

![image-20210520210912751](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3.img/image-20210520210912751.png)

# 字符串变形

```cpp
对于一个给定的字符串，我们需要在线性(也就是O(n))的时间里对它做一些变形。首先这个字符串中包含着一些空格，就像"Hello World"一样，然后我们要做的是把着个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。比如"Hello World"变形后就变成了"wORLD hELLO"。
    
输入："Hello World"
输出："wORLD hELLO"
```

**我的思路：**

- 确定每一个单词的起始结尾下标，反序单词内部，同时转变大小写，A 65 a 97
- 最后整个字符串逆置
- <img src="img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3.img/image-20210522150013715.png" alt="image-20210522150013715" style="zoom:50%;" />

```cpp
//反转单词内部，最后整个逆置
//This is a sample  
//SIHt SI A ELPMAS
//SAMPLE A IS tHIS
class Solution {
public:
    string trans(string s, int n) 
    {
        //确定每一个单词的起始结尾下标，反序，同时转变大小写，A 65 a 97
        for(int i = 0; i < s.size(); ++i)
        {
            int start = i;
            while(s[i] != ' ' && i < s.size())
            {
                if(s[i] >= 'A' && s[i] <= 'Z')    s[i] = 'a' + s[i] - 'A';
                else if(s[i] >= 'a' && s[i] <= 'z')    s[i] = 'A' + s[i] - 'a';
                ++i;
            }
            
            //反转start 到i-1之间
            trans(s, start, i-1);
        }
        
        //最后整个逆置
        reverse(s.begin(), s.end());
        return s;
    }
    
    //反转字符串start到end之间
    void trans(string & s, int start, int end)
    {
        while(start <= end)
        {
            char tmp = s[start];
            s[start] = s[end];
            s[end] = tmp;
            start++;
            end--;
        }
    }
};
```

# 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```cpp
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**我的思路：**

- 假设第一个字符串就是最长公共前缀
- 遍历每个字符串，进行比对，每次更新最长公共前缀

```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) 
    {
        //假设第一个字符串就是最长公共前缀
        //遍历每个字符串，进行比对，每次更新最长公共前缀
        if(strs.empty())    return string("");
        string com = strs.front();
        
        for(int i = 0; i < strs.size(); ++i)
        {
            string tmp;
            for(int j = 0; j < com.size() && j < strs[i].size(); ++j)
            {
                if(com[j] == strs[i][j])
                {
                    tmp += com[j];
                }
                else    break;
            }
            com = tmp;
        }
        return com;
    }
};
```

# 数字翻译成字符串

```cpp
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

输入: 12258
    
输出: 5
    
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

**我的思路：**

- 动态规划：12258的种数 = b2258的种数 + m258的种数
- 先把数字转换成字符串，然后从0下标开始，看该字符串第一个字符和下一个字符组合成的数字是否小于等于25，是的话把这两种情况加起来，不是的话，下标后移
- 用dp数组来作记忆化存储，节省时间

```cpp
class Solution {
public:
    int translateNum(int num) 
    {
        string str = to_string(num);

        //12258 = b2258 + m258
        vector<int> dp(str.size()+1, 0);
        return fun(str, 0, dp);
    }

    int fun(string & str, int index, vector<int> & dp)
    {
        if(index >= str.size()-1)   return 1;  //注意是>=，若是==数组越界
        if(dp[index] != 0)  return dp[index];

        string tmp;
        tmp.push_back(str[index]);
        tmp.push_back(str[index+1]);
        int t = atoi(tmp.c_str());

        if(t <= 25 && tmp[0] != '0')     //注意06不能算2种
        {
            dp[index] = fun(str, index+1, dp) + fun(str, index + 2, dp);
            
        }
        else    
        {
            dp[index] = fun(str, index+1, dp);
        }
        return dp[index];
    }
};
```

