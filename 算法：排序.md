# 合并区间

给出一组区间，请合并所有重叠的区间。

请保证合并后的区间按区间起点升序排列。

```shell
输入：[[10,30],[20,60],[80,100],[150,180]]
输出：[[10,60],[80,100],[150,180]]
```

**我的思路：**

- 通过第一个关键字对所有区间进行排序，如果第一个关键字相等，比较第二个关键字
- 然后遍历所有区间，分情况合并

```cpp
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> merge(vector<Interval> &intervals) 
    {
        if(intervals.empty())    return vector<Interval>();
        
        //通过第一个关键字对所有区间进行排序，如果第一个关键字相等，比较第二个关键字
        sort(intervals.begin(), intervals.end(),[](Interval & x, Interval & y){
            if(x.start == y.start)    return x.end < y.end;
            else    return x.start < y.start;
        });
        
        //遍历所有区间，合并
        vector<Interval>  rt;  //保存合并后的区间，j是合并后的区间的下标
        for(int i = 0, j = -1; i < intervals.size(); ++i)
        {
            if(rt.empty())
            {
                rt.push_back(intervals[i]);
                j++;
            }
            
            if(intervals[i].start <= rt[j].end && intervals[i].end >= rt[j].end)
            {
                rt[j].end = intervals[i].end;
            }
            else if(intervals[i].start <= rt[j].end && intervals[i].end < rt[j].end)
            {
                continue;
            }
            else  //intervals[i].start > rt[j].end
            {
                rt.push_back(intervals[i]);
                j++;
            }
        }
        return rt;
    }
};
```

# 拼接数组元素得到最大组合

将一个数组中的各个元素拼接组合，得到数字最大的组合

如：int arr[6] = {988, 98, 122, 12, 3, 4};拼接组合后最大的数为989884312212

**实现方式一：使用lambda重新定义两个数比大小方式**

```cpp
string largestNumber(vector<int>& nums) 
{
    //重新定义两个数比大小的方式
    sort(nums.begin(), nums.end(), [](const int & x, const int & y){
        string a = to_string(x);
        string b = to_string(y);
        return a+b > b+a;
    });
	//00输出0
    if(nums[0] == 0)    return "0";

    string str;
    for(auto & it : nums)
    {
        str += to_string(it);
    }
    return str;
}
```

或者这样：

```cpp
string largestNumber(vector<int>& nums) 
{
    //重新定义两个数比大小的方式
    sort(nums.begin(), nums.end(), [](const int & x, const int & y){  
        //xy > yx
        if(x == 0 || y == 0)    return x > y;

        int n = 0, y2 = y;
        while(y2 != 0)
        {
            y2 /= 10;
            n++;
        }
        long xy = x * pow(10, n) + y;

        n = 0;
        int x2 = x;
        while(x2 != 0)
        {
            x2 /= 10;
            n++;
        }
        long yx = y * pow(10, n) + x;
        return xy > yx; 
    });

    //00输出0
    if(nums[0] == 0)    return "0";

    string str;
    for(auto & it : nums)
    {
        str += to_string(it);
    }
    return str;
}
```

**实现方式二：自定义函数对象重新定义两个数比大小方式**

```cpp
//重新定义两个数比大小的函数对象
class Comp
{
public:
    bool operator()(const int & x, const int & y)
    {
        //xy > yx
        if(x == 0 || y == 0)    return x > y;

        int n = 0, y2 = y;
        while(y2 != 0)
        {
            y2 /= 10;
            n++;
        }
        long xy = x * pow(10, n) + y;

        n = 0;
        int x2 = x;
        while(x2 != 0)
        {
            x2 /= 10;
            n++;
        }
        long yx = y * pow(10, n) + x;
        return xy > yx; 
    }
};

class Solution {
public:
    string largestNumber(vector<int>& nums) 
    {
        //重新定义两个数比大小的方式
        sort(nums.begin(), nums.end(), Comp());
        
        //00输出0
        if(nums[0] == 0)    return "0";

        string str;
        for(auto & it : nums)
        {
            str += to_string(it);
        }
        return str;
    }
};
```

# 最短无序连续子数组

给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的 最短 子数组，并输出它的长度。

```cpp
输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。

输入：nums = [1,2,3,4]
输出：0
```

**我的思路：**

- 用排好序的和没有排好序的作对比，记录出现不相等时候的首尾

```cpp
int findUnsortedSubarray(vector<int>& nums) 
{
    //0 1 2 4 3 5 6
    //0 1 2 3 4 5 6
    //用排好序的和没有排好序的作对比，记录出现不相等时候的首尾
    vector<int> oldnums(nums);
    sort(nums.begin(), nums.end());

    int start = nums.size()-1;
    int end = 0;

    for(int i = 0; i < nums.size(); ++i)
    {
        if(nums[i] != oldnums[i])
        {
            start = min(i, start);
            end = max(i, end);
        }
    }
    if(start == nums.size()-1)  return 0;
    else    return end-start + 1;
}
```

