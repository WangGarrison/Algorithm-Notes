## 容器盛水问题

给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。

示例：

输入：3,1,2,5,2,4

输出：5

<img align='left' src="img/%E9%A2%98%E7%9B%AE%E6%97%A5%E5%8E%86.img/image-20210504172254340.png" alt="image-20210504172254340" style="zoom:50%;" />

**我的思路：**

- 一个位置的液柱高度只取决于三个因素：左边最高多高、右边最高多高、底多高，所以：

- 从左向右遍历，记录左边最高多高（不算该位置）；再从右向左遍历，记录右边最高多高
- 最后较低的边沿减去底就是当前液柱大小

```cpp
class Solution {
public:
    long long maxWater(vector<int>& arr) 
    {
        //记录左边最高多高（不算该位置），右边最高多高
        int size = arr.size();
        if(size <= 2)    return 0;
        vector<int> leftmax(size, 0);
        vector<int> rightmax(size, 0);
        
        //从左向右：记录左边最高多高
        for(int i = 0; i < size; ++i)
        {
            if(i == 0)    leftmax[i] = arr[i];
            else leftmax[i] = leftmax[i-1] > arr[i-1] ? leftmax[i-1] : arr[i-1];
        }
        //从右向左：记录右边最高多高
        for(int i = size-1; i >= 0; --i)
        {
            if(i == size-1)    rightmax[i] = arr[i];
            else rightmax[i] = rightmax[i+1] > arr[i+1] ? rightmax[i+1] : arr[i+1];
        }
        
        //计算容器大小：较小的边沿-当前位置元素（注意如果减出来小于0则舍弃）
        long long sum = 0;
        for(int i = 1; i < size-1; ++i)
        {
            if(min(leftmax[i], rightmax[i]) - arr[i] > 0)
            {
                sum += min(leftmax[i], rightmax[i]) - arr[i];
            }
        }
        return sum;
    }
};
```

