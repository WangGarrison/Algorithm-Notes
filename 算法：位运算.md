# 不用加减乘除做加法

```shell
写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

输入: a = 1, b = 1
输出: 2
 
提示：
a, b 均可能是负数或 0
结果不会溢出 32 位整数
```

**我的思路：**

- <img align='left' src="img/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97.img/image-20210529215702657.png" alt="image-20210529215702657" style="zoom:50%;" />
- 观察发现，**无进位和** 与 **异或运算** 规律相同，**进位** 和 **与运算** 规律相同（并需左移一位）。因此，无进位和 n 与进位 c 的计算公式如下：
  - n = a⊕b  //非进位和：异或运算
  - c = a&b<<1  //进位：与运算左移一位
- （和 s ）==（非进位和 n）+（进位 c）
- <img align='left' src="img/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97.img/image-20210529221723613.png" alt="image-20210529221723613" style="zoom:50%;" />

```cpp
int add(int a, int b) 
{
    /* a和b第一次计算完进位和、进位之后，将b 赋值为进位
    * 再与a进行第二次计算，直到进位为0，表示从低位到高位全部计算完
    * 所以这里需要循环处理所有的进位
    */
    while (b != 0){
        int temp = (unsigned int)(a & b) << 1;
        a = a^b;    /* a为无进位和 */
        b = temp;   /* b为进位 */
    }
    return a;
}
```

# 只出现一次的数字

```shell
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

输入: [2,2,1]
输出: 1

输入: [4,1,2,1,2]
输出: 4
```

**我的思路：**

- 异或：相同的数字异或结果是0，因此对所有数字进行异或，结果就是只出现一次的那个数
- (*a*1⊕*a*1)⊕(*a*2⊕*a*2)⊕⋯⊕(am⊕am)⊕am+1 == 0⊕0⊕⋯⊕0⊕am+1 == am+1

```cpp
int singleNumber(vector<int>& nums)
{
    int rt = 0;
    for(auto & val : nums)
    {   
        rt ^= val;
    }
    return rt;
}
```

# 数组中数字出现的次数

```shell
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]

输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```

**我的思路：**

- 异或：相同的数字异或结果是0，因此对所有数字进行异或，结果就是出现一次那两个数异或的结果；如果要知道具体是哪两个数，就要分组异或（==相同的数字分在同一组，那两个数字分在不同组==）

- 异或结果为1的位表示那两个数字那位不相同，所以找到异或结果那位为1的数字，通过与该数字进行&运算来分组，为0的分在同一组，为1的分在另一组，则可以完成分组

  - 首先，两个相同的数字的对应位都是相同的，所以一个被分到了某一组，另一个必然被分到这一组，所以满足了条件 2。
  - 那两个出现一次的数字也可以被分在不同的组，因为通过异或结果中的1进行分组，两个数字计算结果必定不同，分在不同组

- 具体步骤：

  - 先对所有数字进行一次异或，得到两个出现一次的数字的异或值。
  - 在异或结果中找到任意为 1 的位。
  - 根据这一位对所有的数字进行分组，在每个组内进行异或操作，得到两个数字

  ![image-20210530003537652](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97.img/image-20210530003537652.png)

```cpp
vector<int> singleNumbers(vector<int>& nums) 
{
    //先对所有数字进行一次异或，得到两个出现一次的数字的异或值。
    int rt = 0;
    for(auto & val : nums)  rt ^= val;
	
    //在异或结果中找到任意为 1 的位。
    int t = 1;
    while((t & rt) == 0)    t <<= 1;
	
    //根据这一位对所有的数字进行分组，在每个组内进行异或操作，得到两个数字
    int a=0, b=0;
    for(auto & val : nums)
    {
        if(val&t)    a ^= val;
        else    b ^= val;
    }

    return {a, b};
}
```

