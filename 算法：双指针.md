# 三数之和/和为0的三元组

```cpp
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]    
```

**我的思路：**

- 先排序，固定i，固定第一个元素，然后双指针找0-nums[i]，j和k一个在前，一个在后同时遍历
- 注意：为了保证不包含重复的三元组，每次都要让控制循环的遍历的元素和上次不同

![image-20210325233558176](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88.img/image-20210325233558176.png)

```cpp
vector<vector<int>> threeSum(vector<int>& nums) 
{
    //先排序，然后固定第一个数，双指针遍历找0-nums[i]
    sort(nums.begin(), nums.end());
    vector<vector<int>> vvec;  //存储结果集      

    for(int i = 0; i < nums.size(); ++i)
    {
        int target = 0 - nums[i];
        if(i > 0 && nums[i] == nums[i-1]) continue;  //避免重复

        for(int j = i + 1, k = nums.size()-1; j < k; )
        {
            if(j > i+1 && nums[j] == nums[j-1])   //避免重复
            {
                j++;
                continue;
            }

            if(nums[j] + nums[k] == target)
            {
                vvec.push_back({nums[i], nums[j], nums[k]});
                j++;
            }
            else if(nums[j] + nums[k] < target)
            {
                j++;
            }
            else
            {
                while(j < k && nums[j] + nums[k] > target)
                {
                    k--;
                }
            }
        }
    }
    return vvec;
}
```

# 和为s的两个数字(对撞双指针)

```cpp
输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
    
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```

**我的思路：**

- ==对撞双指针==：一个从前往后扫描，一个从后往前扫描，如果和大于target，则后面的往前，如果和小于target，则前面的往后

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // 双指针同时从头尾开始遍历，和小于目标值，头指针++，大于目标值，尾指针--
        int left = 0;
        int right = nums.size()-1;

        while(left < right) {
            if(nums[left] + nums[right] < target) {
                left++;
            } else if(nums[left] + nums[right] > target) {
                right--;
            } else {
                return {nums[left], nums[right]};
            }
        }
        return {};
    }
};
```

# 最接近的三数之和

```cpp
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

**我的思路：**

- 先排序，固定一个数，然后其他两个数双指针遍历，每次更新三数之和

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) 
    {
        if(nums.size() < 3)
        {
            return -1;
        }
        
        //先排序
        sort(nums.begin(), nums.end());

        //固定一个数，然后其他两个数双指针遍历，每次更新三数之和
        int cursum = 0;
        int presum = nums[0] + nums[1] + nums[2];
        for(int i = 0; i < nums.size(); ++i)
        {
            //j，k双指针遍历
            int j = i + 1;
            int k = nums.size()-1;
            while(j < k)
            {
                cursum = nums[i] + nums[j] + nums[k];
                if(abs(cursum-target) < abs(presum-target))//更新sum
                {
                    presum = cursum;
                }
                if(nums[i] + nums[j] + nums[k] > target)
                {
                    k--;
                }
                else
                {
                    j++;
                }
            }
        }
        return presum;
    }
};
```

# 调整数组顺序使奇数位于偶数之前

```cpp
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```

**我的思路：**

- 双指针首尾同时遍历数组，头指针从前往后找偶数，找到一个，然后尾指针从后往前找一个奇数
- 交换，继续这样，直到相遇

```cpp
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        // 双指针首尾同时遍历数组，头指针从前往后找偶数，找到一个，然后尾指针从后往前找一个奇数
        // 交换，继续这样，直到相遇
        int left = 0;
        int right = nums.size()-1;

        while(left < right) {
            while(left < right && nums[left] % 2 == 1) left++;
            while(left < right && nums[right] % 2 == 0) right--;
            
            if(left < right) {
                swap(nums[left], nums[right]);
            }
        }
        return  nums;
    }
};
```

# 删除有序数组的重复项

```cpp
给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

**我的思路：**

- 原地去重, 确定新串的第一个元素为原串的第一个元素，遍历旧串，找到和已确定的元素不相等的赋值到后面，新旧指标同时加一

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& vec) {
        if(vec.size() <= 1) {
            return vec.size();
        }

        // 原地去重, 确定新串的第一个元素为原串的第一个元素，遍历旧串，找到和已确定的元素不相等的赋值到后面，新旧指标同时加一
        int newI = 0;  // 相当于慢指针
        int oldI = 1;  // 相当于快指针

        // 01
        while(oldI < vec.size()) {
            if(vec[oldI] != vec[newI]) {
                newI++;
                vec[newI] = vec[oldI];
                oldI++;
            } else {
                oldI++;
            }
        }
        
        return newI+1;
    }
};
```



