# 三数之和/和为0的三元组

```cpp
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]    
```

**我的思路：**

- 先排序，固定i，固定第一个元素，然后双指针找0-nums[i]，j和k一个在前，一个在后同时遍历
- 注意：为了保证不包含重复的三元组，每次都要让控制循环的遍历的元素和上次不同

![image-20210325233558176](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88.img/image-20210325233558176.png)

```cpp
vector<vector<int>> threeSum(vector<int>& nums) 
{
    //先排序，然后固定第一个数，双指针遍历找0-nums[i]
    sort(nums.begin(), nums.end());
    vector<vector<int>> vvec;  //存储结果集      

    for(int i = 0; i < nums.size(); ++i)
    {
        int target = 0 - nums[i];
        if(i > 0 && nums[i] == nums[i-1]) continue;  //避免重复

        for(int j = i + 1, k = nums.size()-1; j < k; )
        {
            if(j > i+1 && nums[j] == nums[j-1])   //避免重复
            {
                j++;
                continue;
            }

            if(nums[j] + nums[k] == target)
            {
                vvec.push_back({nums[i], nums[j], nums[k]});
                j++;
            }
            else if(nums[j] + nums[k] < target)
            {
                j++;
            }
            else
            {
                while(j < k && nums[j] + nums[k] > target)
                {
                    k--;
                }
            }
        }
    }
    return vvec;
}
```

# 和为s的两个数字(对撞双指针)

```cpp
输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
    
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```

**我的思路：**

- ==对撞双指针==：一个从前往后扫描，一个从后往前扫描，如果和大于target，则后面的往前，如果和小于target，则前面的往后

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) 
    {
        //对撞双指针：一个从前往后扫描，一个从后往前扫描，
        //如果和大于target，则后面的往前，如果和小于target，则前面的往后
        vector<int> rt;
        int low = 0;
        int high = nums.size()-1;

        while(low < high)
        {
            if(nums[low] <target - nums[high]) //nums[low] + nums[high] <target
            {
                low++;
            }
            else if(nums[low] > target - nums[high])
            {
                high--;
            }
            else
            {
                rt.push_back(nums[low]);
                rt.push_back(nums[high]);
                break;
            }
        }
        return rt;
    }
};
```

# 最接近的三数之和

```cpp
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

**我的思路：**

- 先排序，固定一个数，然后其他两个数双指针遍历，每次更新三数之和

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) 
    {
        if(nums.size() < 3)
        {
            return -1;
        }
        
        //先排序
        sort(nums.begin(), nums.end());

        //固定一个数，然后其他两个数双指针遍历，每次更新三数之和
        int cursum = 0;
        int presum = nums[0] + nums[1] + nums[2];
        for(int i = 0; i < nums.size(); ++i)
        {
            //j，k双指针遍历
            int j = i + 1;
            int k = nums.size()-1;
            while(j < k)
            {
                cursum = nums[i] + nums[j] + nums[k];
                if(abs(cursum-target) < abs(presum-target))//更新sum
                {
                    presum = cursum;
                }
                if(nums[i] + nums[j] + nums[k] > target)
                {
                    k--;
                }
                else
                {
                    j++;
                }
            }
        }
        return presum;
    }
};
```



