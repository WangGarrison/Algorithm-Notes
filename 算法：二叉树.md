# 前序、中序重建二叉树

```shell
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
```

**我的思路：**

- 根据前序遍历可以确定根节点
- 然后在中序遍历中可以找到该根位置，进而确定其左右两边的结点
- 然后再确定子结点的前中序遍历序列，建立子树
- ![image-20210504105516068](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91.img/image-20210504105516068.png)

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) 
    {
        //根据前序可以确定根，通过中序可以知道根的左右
        return buildTree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
    }

    TreeNode* buildTree(vector<int> & preorder, int i, int j, 
                        vector<int>& inorder, int m, int n)
    {
        if(i > j || m > n)  return nullptr;

        //根据前序遍历确定根节点
        TreeNode* root = new TreeNode(preorder[i]);

        //然后在中序遍历中找到根节点的位置，进而确定其左右两边的结点
        int k;
        for(k = 0; k < n; ++k)
        {
            if(inorder[k] == preorder[i])   break;
        }

        //然后再确定子结点的前中序遍历序列，建立子树
        root->left = buildTree(preorder, i+1, i+(k-m), inorder, m, k-1);
        root->right = buildTree(preorder, i+(k-m)+1, j, inorder,k+1, n);

        return root;
    } 
};
```

