# 前序、中序重建二叉树

```shell
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
```

**我的思路：**

- 根据前序遍历可以确定根节点
- 然后在中序遍历中可以找到该根位置，进而确定其左右两边的结点
- 然后再确定子结点的前中序遍历序列，建立子树
- ![image-20210504105516068](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91.img/image-20210504105516068.png)

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) 
    {
        //根据前序可以确定根，通过中序可以知道根的左右
        return buildTree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
    }

    TreeNode* buildTree(vector<int> & preorder, int i, int j, 
                        vector<int>& inorder, int m, int n)
    {
        if(i > j || m > n)  return nullptr;

        //根据前序遍历确定根节点
        TreeNode* root = new TreeNode(preorder[i]);

        //然后在中序遍历中找到根节点的位置，进而确定其左右两边的结点
        int k;
        for(k = 0; k < n; ++k)
        {
            if(inorder[k] == preorder[i])   break;
        }

        //然后再确定子结点的前中序遍历序列，建立子树
        root->left = buildTree(preorder, i+1, i+(k-m), inorder, m, k-1);
        root->right = buildTree(preorder, i+(k-m)+1, j, inorder,k+1, n);

        return root;
    } 
};
```

# 求二叉树层数、深度

**递归解法**

- 二叉树的深度等于左子树的深度和右子树的深度的最大值加1

```cpp
int Depth(TreeNode* root) 
{
    if(root == nullptr)    return 0;
    return max(Depth(root->left), Depth(root->right)) + 1;
}
```

**非递归解法**

- 利用层序遍历，每次出队列都要把一层的处理完

- > 相似思路的题目：[判断二叉树是否为满二叉树](#判断二叉树是否为满二叉树)

```cpp
//获取深度（非递归）
int GetDepth(BTNode * ptr)
{
	if (ptr == nullptr) return 0;
	int h = 0;
	queue<BTNode*> que;
	que.push(ptr);

	while (!que.empty())
	{
		int n = que.size(); //这一层的结点的个数
		while (n--)//要把这一层的出完
		{
			ptr = que.front();	que.pop();
			if (ptr->left != nullptr)		que.push(ptr->left);
			if (ptr->right != nullptr)		que.push(ptr->right);
		}
		h++;
	}
	return h;
}
```

# 判断二叉树是否为满二叉树

**我的思路1：**

- 层序遍历二叉树，统计所有结点个数，判断最后结点个数是否是2^(h+1) - 1，（根的h是0）

**我的思路2：**

- 利用层序遍历的思路，每次都处理一整层并且判断该层结点个数是否为2^h个

```cpp
bool IsFull(BTNode * ptr)
{
	if (ptr == nullptr) return true;
	int h = 0;
	queue<BTNode*> que;
	que.push(ptr);

	while (!que.empty())
	{
		int n = que.size(); //这一层的结点的个数
        if(n != pow(2, h))
        {
            return false;
		}
		while (n--)//要把这一层的出完
		{
			ptr = que.front();	que.pop();
			if (ptr->left != nullptr)		que.push(ptr->left);
			if (ptr->right != nullptr)		que.push(ptr->right);
		}
		h++;
	}
	return true;
}
```

# 判断二叉树是否是平衡二叉树

平衡树：任意结点的左右子树的高度<=1

**我的思路：**

- 遍历二叉树，给每个结点对应的函数栈上记录一个该结点所在的高度，==回溯的时候将高度返回回去==，用flag记录是否失衡

```cpp
class Solution {
public:
    bool flag = true; //true是平衡二叉树，false不是
    
    bool IsBalanced_Solution(TreeNode* root) 
    {
        level(root);
        return flag;
    }
    
    //深度优先遍历，回溯的时候，记录每个结点对应的level
    int level(TreeNode* root)
    {
        if(root == nullptr)    return 0;
        
        int lh = level(root->left) + 1;
        if(!flag)    return lh;
        int rh = level(root->right) + 1;
        if(!flag)    return rh;
        
        if(abs(lh-rh)>1)    flag = false;
        
        return max(lh, rh);
    }
};
```





