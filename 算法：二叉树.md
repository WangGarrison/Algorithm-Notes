# 前序、中序重建二叉树

```shell
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
```

**我的思路：**

- 根据前序遍历可以确定根节点
- 然后在中序遍历中可以找到该根位置，进而确定其左右两边的结点
- 然后再确定子结点的前中序遍历序列，建立子树
- ![image-20210504105516068](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91.img/image-20210504105516068.png)

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) 
    {
        //根据前序可以确定根，通过中序可以知道根的左右
        return buildTree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
    }

    TreeNode* buildTree(vector<int> & preorder, int i, int j, 
                        vector<int>& inorder, int m, int n)
    {
        if(i > j || m > n)  return nullptr;

        //根据前序遍历确定根节点
        TreeNode* root = new TreeNode(preorder[i]);

        //然后在中序遍历中找到根节点的位置，进而确定其左右两边的结点
        int k;
        for(k = 0; k < n; ++k)
        {
            if(inorder[k] == preorder[i])   break;
        }

        //然后再确定子结点的前中序遍历序列，建立子树
        root->left = buildTree(preorder, i+1, i+(k-m), inorder, m, k-1);
        root->right = buildTree(preorder, i+(k-m)+1, j, inorder,k+1, n);

        return root;
    } 
};
```

# 输出二叉树的右视图

请根据二叉树的前序遍历，中序遍历恢复二叉树，并打印出二叉树的右视图

```shell
输入：[1,2,4,5,3],[4,2,5,1,3]

      1
    /   \
   2     3
 /   \
4     5

输出：[1,3,5]
```

**我的思路：**

- 重建二叉树：根据前序可以确定根节点，再在中序遍历序列中找到根节点位置，进而知道左子树与右子树的序列
- 输出右视图：层序遍历该二叉树，输出每一层最右边的结点

```cpp
class Solution {
public:
    vector<int> solve(vector<int>& preorder, vector<int>& inorder) 
    {
        //根据前序可以确定根节点，再在中序遍历序列中找到根节点位置
        TreeNode* root = rebuild(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
        
        //输出二叉树的右视图
        return showRight(root);
    }
    
    //输出二叉树右视图
    vector<int> showRight(TreeNode* root)
    {
        if(root == nullptr)    return vector<int>();
        
        vector<int> rt;
        
        //层序遍历该二叉树，输出最右边的结点
        queue<TreeNode*> que1, que2;
        que1.push(root);
        
        while(!que1.empty() || !que2.empty())
        {
            vector<int> vec1, vec2;
            while(!que1.empty())
            {
                TreeNode* cur = que1.front(); que1.pop();
                vec1.push_back(cur->val);
                
                if(cur->left != nullptr)    que2.push(cur->left);
                if(cur->right != nullptr)    que2.push(cur->right);
            }
            if(!vec1.empty())    rt.push_back(vec1[vec1.size()-1]);
            
            while(!que2.empty())
            {
                TreeNode* cur = que2.front(); que2.pop();
                vec2.push_back(cur->val);
                
                if(cur->left != nullptr)    que1.push(cur->left);
                if(cur->right != nullptr)    que1.push(cur->right);
            }
            if(!vec2.empty())    rt.push_back(vec2[vec2.size()-1]);
        }
        return rt;
    }
    
    //根据前序和中序构建二叉树
    TreeNode* rebuild(vector<int> & preorder, int i, int j, vector<int> & inorder, int m, int n)
    {
        if(i > j || m > n)    return nullptr;
        
        TreeNode* root = new TreeNode(preorder[i]);
        
        //在中序遍历中找到根节点
        int k;
        for( k = m; k <= n; ++k)
        {
            if(inorder[k] == preorder[i])
            {
                break;
            }
        }
        
        root->left = rebuild(preorder, i+1, i+k-m, inorder, m, k-1);
        root->right = rebuild(preorder, i+k-m+1, j, inorder, k+1, n);
        return root;
    }
    
};
```



# 求二叉树层数、深度

**递归解法**

- 二叉树的深度等于左子树的深度和右子树的深度的最大值加1

```cpp
int Depth(TreeNode* root) 
{
    if(root == nullptr)    return 0;
    return max(Depth(root->left), Depth(root->right)) + 1;
}
```

**非递归解法**

- 利用层序遍历，每次出队列都要把一层的处理完

- > 相似思路的题目：[判断二叉树是否为满二叉树](#判断二叉树是否为满二叉树)

```cpp
//获取深度（非递归）
int GetDepth(BTNode * ptr)
{
	if (ptr == nullptr) return 0;
	int h = 0;
	queue<BTNode*> que;
	que.push(ptr);

	while (!que.empty())
	{
		int n = que.size(); //这一层的结点的个数
		while (n--)//要把这一层的出完
		{
			ptr = que.front();	que.pop();
			if (ptr->left != nullptr)		que.push(ptr->left);
			if (ptr->right != nullptr)		que.push(ptr->right);
		}
		h++;
	}
	return h;
}
```

# 判断二叉树是否为满二叉树

**我的思路1：**

- 层序遍历二叉树，统计所有结点个数，判断最后结点个数是否是2^(h+1) - 1，（根的h是0）

**我的思路2：**

- 利用层序遍历的思路，每次都处理一整层并且判断该层结点个数是否为2^h个

```cpp
bool IsFull(BTNode * ptr)
{
	if (ptr == nullptr) return true;
	int h = 0;
	queue<BTNode*> que;
	que.push(ptr);

	while (!que.empty())
	{
		int n = que.size(); //这一层的结点的个数
        if(n != pow(2, h))
        {
            return false;
		}
		while (n--)//要把这一层的出完
		{
			ptr = que.front();	que.pop();
			if (ptr->left != nullptr)		que.push(ptr->left);
			if (ptr->right != nullptr)		que.push(ptr->right);
		}
		h++;
	}
	return true;
}
```

# 判断二叉树是否是平衡二叉树

平衡树：任意结点的左右子树的高度<=1

**我的思路：**

- 遍历二叉树，给每个结点对应的函数栈上记录一个该结点所在的高度，==回溯的时候将高度返回回去==，用flag记录是否失衡

```cpp
class Solution {
public:
    bool flag = true; //true是平衡二叉树，false不是
    
    bool IsBalanced_Solution(TreeNode* root) 
    {
        level(root);
        return flag;
    }
    
    //深度优先遍历，回溯的时候，记录每个结点对应的level
    int level(TreeNode* root)
    {
        if(root == nullptr)    return 0;
        
        int lh = level(root->left) + 1;
        if(!flag)    return lh;
        int rh = level(root->right) + 1;
        if(!flag)    return rh;
        
        if(abs(lh-rh)>1)    flag = false;
        
        return max(lh, rh);
    }
};
```

# 二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

    示例：
    给定二叉树 [3,9,20,null,null,15,7]
        3
       / \
      9  20
        /  \
       15   7
    返回它的最大深度 3 。

**我的思路：**

- 二叉树的深度等于左子树的深度和右子树的深度的最大值加1

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) 
    {
        if(root == nullptr) 
        {
            return 0;
        }
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

# 二叉搜索树的最近公共祖先

给定一个二叉搜索树(BS树）, 找到该树中两个指定节点的最近公共祖先。一个节点也可以是它自己的祖先

> 在二叉搜索树中：
>
> 1.若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。
>
> 2.若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。
>
> 3.任意结点的左、右子树也分别为二叉搜索树。

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

 ![img](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91.img/binarysearchtree_improved.png)

```shell
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

**我的思路1：**

- 二叉搜索树，左小右大，遍历BS树，找到p，q结点，并记录遍历时候经过的节点
- 然后找到分叉点就是公共祖先

```cpp
class Solution {
public:
    //在二叉搜索树中找到node，并把路径记录在向量中返回
    vector<TreeNode*> getPath(TreeNode * root, TreeNode * node)
    {
        vector<TreeNode*> path;
        while(root != nullptr && root != node)
        {
            path.push_back(root);
            if(node->val > root->val) //在右子树中再找
            {
                root = root->right;
            }
            else//在左子树中再找
            {
                root = root->left;
            }
        }
        path.push_back(root); //把找到的节点也放进去
        return path;
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
    {
        //二叉搜索树，左小右大，遍历BS树，找到p，q结点，并记录遍历时候经过的节点
        //然后找到分叉点就是公共祖先
        vector<TreeNode*> path_p = getPath(root, p);
        vector<TreeNode*> path_q = getPath(root, q);

        //在两个路径中找分叉的节点
        int i = 0;
        TreeNode* rt = root;
        while(i < path_p.size() && i < path_q.size())
        {
            if(path_p[i] == path_q[i])
            {
                rt = path_p[i];
                i++;
            }
            else
            {
                break;
            }
        }
        return rt;
    }
};
```

**我的思路2：**

- 因为二叉搜索树左小右大，所以可以遍历该树，如果pq比结点值都大，则在右子树中继续

- pq比结点值都小，在左子树中继续，如果pq一个比该节点大，一个比结点小，那么这就是分叉点，就是公共祖先

  <img align = 'left' src="img/3.11%E5%BC%80%E5%A7%8B%E7%9A%84%E9%A2%98.img/image-20210314170250414.png" alt="image-20210314170250414" style="zoom:50%;" />

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
    {
        //因为二叉搜索树左小右大，所以可以遍历该树，如果pq比结点值都大，则在右子树中继续
        //比结点值都小，在左子树中继续，如果pq一个比该节点大，一个比结点小，那么这就是分叉点，就是公共祖先
        while(root != nullptr)
        {
            if(p->val > root->val && q->val > root->val)
            {
                root = root->right;
            }
            else if(p->val < root->val && q->val < root->val)
            {
                root = root->left;
            }
            else
            {
                return root;
            }
        }
        return root;
    }
};
```

# 二叉树根到叶子的所有路径和

给定一个仅包含数字0−9 的二叉树，每一条从根节点到叶子节点的路径都可以用一个数字表示。

例如根节点到叶子节点的一条路径是1→2→3,那么这条路径就用123 来代替。

找出根节点到叶子节点的所有路径表示的数字之和

例如：

<img align='left' src="img/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91.img/image-20210512133807120.png" alt="image-20210512133807120" style="zoom:70%;" />

这颗二叉树一共有两条路径，根节点到叶子节点的路径1→2 用数字12 代替，根节点到叶子节点的路径1→3 用数字13 代替

所以答案为12+13=25

**我的思路：**

- 深度优先遍历二叉树，遍历到终端结点的时候计算该条路径的值

```cpp
class Solution {
private:
    int sum = 0;
    vector<int> path;
public:
    int sumNumbers(TreeNode* root) 
    {
        //深度优先遍历二叉树，遍历到终端结点的时候计算该条路径的值
        depth(root);
        return sum;
    }
    
    void depth(TreeNode* root)
    {
        if(root == nullptr)    return;
        
        path.push_back(root->val);
        
        //遍历到终端结点了，计算路径上的值组成的数字
        if(root->left == nullptr && root->right == nullptr)
        {
            int s = 0;
            for(auto & v : path)
            {
                s = s * 10 + v;
            }
            sum += s;
        }
        
        depth(root->left);
        depth(root->right);
        
        path.pop_back();
    }
};
```

# 二叉树中和为某一值的路径

```cpp
输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
给定如下二叉树，以及目标和 target = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:
[
   [5,4,11,2],
   [5,8,4,5]
]

```

**我的思路：**

- 深度优先遍历二叉树，每次遍历的时候记录之前的结点，遍历到叶子结点的时候看之前的和是否为target
- 是的话将该路径保存，不是的话该路径删除一个元素，回溯

```cpp
class Solution {
private:
    vector<int> onepath; 		 //一条路径
    vector<vector<int>> sumpath; //所有路径

public:
    vector<vector<int>>& pathSum(TreeNode* root, int target)
    {
        depth(root, target);
        return sumpath;
    }

    //深度优先遍历二叉树，每次遍历的时候记录之前的结点，遍历到叶子的时候看之前的和是否为target
    //是的话将该路径保存，不是的话该路径删除一个元素，回溯
    void depth(TreeNode* root, int target)
    {      
        if(root == nullptr) return;  //判断条件可以写成!root
        
        onepath.push_back(root->val);

        //遍历到底的时候看之前的和是否为target
        if (root->left == nullptr && root->right == nullptr) 
        {
            int sum = 0;
            for (auto & it : onepath)
            {
                sum += it;
            }

            if (target == sum)  sumpath.push_back(onepath);
        }
        
        pathSum(root->left, target);
        pathSum(root->right, target);

        onepath.pop_back();
    }
};
```

# 从上到下打印二叉树II

```cpp
从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如:
给定二叉树: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
```

**我的思路：**

- 双队列：队列a存储第一层，队列b存储第二层

```cpp
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode* root) 
    {
        vector<vector<int>> vvec;
        if(root == nullptr)    return vvec;
        
        queue<TreeNode*> quea;
        queue<TreeNode*> queb;
        quea.push(root);
        TreeNode* cur;
        
        while(!quea.empty() || !queb.empty())
        {
            vector<int> veca;
            vector<int> vecb;
            while(!quea.empty())
            {
                cur = quea.front(); quea.pop();
                veca.push_back(cur->val);
                
                if(cur->left != nullptr)	queb.push(cur->left);
                if(cur->right != nullptr)	queb.push(cur->right);
            }
            if(!veca.empty())    vvec.push_back(veca);
            
            while(!queb.empty())
            {
                cur = queb.front(); queb.pop();
                 vecb.push_back(cur->val);
                if(cur->left != nullptr)	quea.push(cur->left);
                if(cur->right != nullptr)	quea.push(cur->right);  
            }
            if(!vecb.empty())    vvec.push_back(vecb);
        }
        return vvec;
    }
};
```

# Z字形遍历二叉树

 给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）
例如：
给定的二叉树是{3,9,20,#,#,15,7},
<img src="img/%E9%A2%98%E7%9B%AE%E6%97%A5%E5%8E%86.img/999991351_1596788654427_630E55F47DBAFBF72C88E265929E43F7" alt="img" style="zoom:50%;" />

该二叉树之字形层序遍历的结果是

> [
>
> [3],
>
> [20,9],
>
> [15,7]
>
> ]

**我的思路：**

- 准备两个栈，根结点放入栈1，栈1不空时，出元素，将元素的==左右==孩子放入栈2

- 栈2不为空时，出元素，将元素的==右左==孩子放入第一个栈

  ![image-20210330221223640](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91.img/image-20210330221223640-1620921030122.png)

```cpp
vector<vector<int> > zigzagLevelOrder(TreeNode* root) 
{
    vector<vector<int>>  matrix;
    if(root == nullptr)    return matrix;  //别忘了
    //两个栈
    stack<TreeNode*> st1;
    stack<TreeNode*> st2;

    st1.push(root);

    while(!st1.empty() || !st2.empty())
    {
        vector<int> vec1;
        while(!st1.empty())
        {
            TreeNode* cur = st1.top();    st1.pop();
            vec1.push_back(cur->val);

            if(cur->left != nullptr)    st2.push(cur->left);
            if(cur->right != nullptr)    st2.push(cur->right);
        }
        if(!vec1.empty())    matrix.push_back(vec1);  //注意判空

        vector<int> vec2;
        while(!st2.empty())
        {
            TreeNode* cur = st2.top();    st2.pop();
            vec2.push_back(cur->val);

            if(cur->right != nullptr)    st1.push(cur->right);
            if(cur->left != nullptr)    st1.push(cur->left);
        }
        if(!vec2.empty())    matrix.push_back(vec2);
    }
    return matrix;
}
```

# 二叉搜索树的最小绝对差

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

```cpp
输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
```

**我的思路1：**（递归）

- 中序遍历，每次检查前驱与当前结点的差值

```cpp
class Solution {
private:
    int Min = INT_MAX;
    int pre = -1;

public:
    void dfs(TreeNode* root)
    {
        if(root == nullptr) return;

        dfs(root->left);

        if(pre != -1)
        {
            Min = min(root->val - pre, Min);
        }
        pre = root->val;
        
        dfs(root->right);
    }

    int getMinimumDifference(TreeNode* root) 
    {
        //中序遍历，每次检查前驱与当前结点的差值
        dfs(root);
        return Min;
    }
};
```

**我的思路2：**（非递归）

- 中序遍历，每次更新前驱结点和当前结点的差值

```cpp
class Solution {
public:

    int getMinimumDifference(TreeNode* root) 
    {
        if(root == nullptr) return 0;

        //中序遍历，每次更新前驱结点和当前结点的差值
        int pre = -1;
        int Min = INT_MAX;

        //遍历到最左边
        stack<TreeNode*> sta;

        while(root != nullptr || !sta.empty())
        {
            while(root != nullptr)
            {
                sta.push(root);
                root = root->left;
            }
            //左边到底了
            TreeNode* cur = sta.top();  sta.pop();
            if(pre != -1)
            {
                Min = min(cur->val - pre, Min);
            }
            pre = cur->val;

            root = cur->right;
        }
        
        return Min;
    }
};
```

# 判断二叉搜索树

判断一棵二叉树是否是二叉搜索树

**我的思路：**

利用BST树中序遍历是递增有序序列的性质，==中序遍历二叉树，每次比较该结点值是否大于前驱结点值==，大于的话，更新前驱，继续遍历，否则返回假

```cpp
//判断是否是搜索二叉树
bool judgeBST(TreeNode* root)
{
    //中序遍历，每次比较当前值是否大于前驱
    static bool flag = true;
    static TreeNode* pre = nullptr;
    if(root == nullptr)    return true;
    if(!flag)    return false;

    judgeBST(root->left);

    if(pre != nullptr)
    {
        if(root->val < pre->val)
        {
            flag = false;
            return false;
        }
    }
    pre = root;

    judgeBST(root->right);

    return flag;
}
```

# 判断完全二叉树

判断一棵二叉树是否是完全二叉树

**我的思路：**

- 层序遍历，空指针也入队列，然后检查队列，遍历到空指针的时候，看后面的是不是都是空指针

```cpp
bool judgeCOM(TreeNode* root)
{
    //层序遍历，空指针也入队列，然后检查队列，遍历到空指针的时候，看后面的是不是都是空指针
    if(root == nullptr)    return true;
    queue<TreeNode*> que1, que2;
    que1.push(root);

    while(!que1.empty())
    {
        TreeNode* cur = que1.front();
        que1.pop();
        que2.push(cur);

        if(cur != nullptr)    
        {
            que1.push(cur->left);
            que1.push(cur->right);
        }
    }

    while(que2.front() != nullptr)    que2.pop();

    while(!que2.empty())
    {
        if(que2.front() != nullptr)    return false;
        que2.pop();
    }
    return true;
}
```

