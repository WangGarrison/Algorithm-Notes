# 前序、中序重建二叉树

```shell
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
```

**我的思路：**

- 根据前序遍历可以确定根节点
- 然后在中序遍历中可以找到该根位置，进而确定其左右两边的结点
- 然后再确定子结点的前中序遍历序列，建立子树
- ![image-20210504105516068](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91.img/image-20210504105516068.png)

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) 
    {
        //根据前序可以确定根，通过中序可以知道根的左右
        return buildTree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
    }

    TreeNode* buildTree(vector<int> & preorder, int i, int j, 
                        vector<int>& inorder, int m, int n)
    {
        if(i > j || m > n)  return nullptr;

        //根据前序遍历确定根节点
        TreeNode* root = new TreeNode(preorder[i]);

        //然后在中序遍历中找到根节点的位置，进而确定其左右两边的结点
        int k;
        for(k = 0; k < n; ++k)
        {
            if(inorder[k] == preorder[i])   break;
        }

        //然后再确定子结点的前中序遍历序列，建立子树
        root->left = buildTree(preorder, i+1, i+(k-m), inorder, m, k-1);
        root->right = buildTree(preorder, i+(k-m)+1, j, inorder,k+1, n);

        return root;
    } 
};
```

# 求二叉树层数、深度

**递归解法**

- 二叉树的深度等于左子树的深度和右子树的深度的最大值加1

```cpp
int Depth(TreeNode* root) 
{
    if(root == nullptr)    return 0;
    return max(Depth(root->left), Depth(root->right)) + 1;
}
```

**非递归解法**

- 利用层序遍历，每次出队列都要把一层的处理完

- > 相似思路的题目：[判断二叉树是否为满二叉树](#判断二叉树是否为满二叉树)

```cpp
//获取深度（非递归）
int GetDepth(BTNode * ptr)
{
	if (ptr == nullptr) return 0;
	int h = 0;
	queue<BTNode*> que;
	que.push(ptr);

	while (!que.empty())
	{
		int n = que.size(); //这一层的结点的个数
		while (n--)//要把这一层的出完
		{
			ptr = que.front();	que.pop();
			if (ptr->left != nullptr)		que.push(ptr->left);
			if (ptr->right != nullptr)		que.push(ptr->right);
		}
		h++;
	}
	return h;
}
```

# 判断二叉树是否为满二叉树

**我的思路1：**

- 层序遍历二叉树，统计所有结点个数，判断最后结点个数是否是2^(h+1) - 1，（根的h是0）

**我的思路2：**

- 利用层序遍历的思路，每次都处理一整层并且判断该层结点个数是否为2^h个

```cpp
bool IsFull(BTNode * ptr)
{
	if (ptr == nullptr) return true;
	int h = 0;
	queue<BTNode*> que;
	que.push(ptr);

	while (!que.empty())
	{
		int n = que.size(); //这一层的结点的个数
        if(n != pow(2, h))
        {
            return false;
		}
		while (n--)//要把这一层的出完
		{
			ptr = que.front();	que.pop();
			if (ptr->left != nullptr)		que.push(ptr->left);
			if (ptr->right != nullptr)		que.push(ptr->right);
		}
		h++;
	}
	return true;
}
```

# 判断二叉树是否是平衡二叉树

平衡树：任意结点的左右子树的高度<=1

**我的思路：**

- 遍历二叉树，给每个结点对应的函数栈上记录一个该结点所在的高度，==回溯的时候将高度返回回去==，用flag记录是否失衡

```cpp
class Solution {
public:
    bool flag = true; //true是平衡二叉树，false不是
    
    bool IsBalanced_Solution(TreeNode* root) 
    {
        level(root);
        return flag;
    }
    
    //深度优先遍历，回溯的时候，记录每个结点对应的level
    int level(TreeNode* root)
    {
        if(root == nullptr)    return 0;
        
        int lh = level(root->left) + 1;
        if(!flag)    return lh;
        int rh = level(root->right) + 1;
        if(!flag)    return rh;
        
        if(abs(lh-rh)>1)    flag = false;
        
        return max(lh, rh);
    }
};
```

# 二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

    示例：
    给定二叉树 [3,9,20,null,null,15,7]
        3
       / \
      9  20
        /  \
       15   7
    返回它的最大深度 3 。

**我的思路：**

- 二叉树的深度等于左子树的深度和右子树的深度的最大值加1

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) 
    {
        if(root == nullptr) 
        {
            return 0;
        }
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

# 二叉搜索树的最近公共祖先

给定一个二叉搜索树(BS树）, 找到该树中两个指定节点的最近公共祖先。一个节点也可以是它自己的祖先

> 在二叉搜索树中：
>
> 1.若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。
>
> 2.若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。
>
> 3.任意结点的左、右子树也分别为二叉搜索树。

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

 ![img](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91.img/binarysearchtree_improved.png)

```shell
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

**我的思路1：**

- 二叉搜索树，左小右大，遍历BS树，找到p，q结点，并记录遍历时候经过的节点
- 然后找到分叉点就是公共祖先

```cpp
class Solution {
public:
    //在二叉搜索树中找到node，并把路径记录在向量中返回
    vector<TreeNode*> getPath(TreeNode * root, TreeNode * node)
    {
        vector<TreeNode*> path;
        while(root != nullptr && root != node)
        {
            path.push_back(root);
            if(node->val > root->val) //在右子树中再找
            {
                root = root->right;
            }
            else//在左子树中再找
            {
                root = root->left;
            }
        }
        path.push_back(root); //把找到的节点也放进去
        return path;
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
    {
        //二叉搜索树，左小右大，遍历BS树，找到p，q结点，并记录遍历时候经过的节点
        //然后找到分叉点就是公共祖先
        vector<TreeNode*> path_p = getPath(root, p);
        vector<TreeNode*> path_q = getPath(root, q);

        //在两个路径中找分叉的节点
        int i = 0;
        TreeNode* rt = root;
        while(i < path_p.size() && i < path_q.size())
        {
            if(path_p[i] == path_q[i])
            {
                rt = path_p[i];
                i++;
            }
            else
            {
                break;
            }
        }
        return rt;
    }
};
```

**我的思路2：**

- 因为二叉搜索树左小右大，所以可以遍历该树，如果pq比结点值都大，则在右子树中继续

- pq比结点值都小，在左子树中继续，如果pq一个比该节点大，一个比结点小，那么这就是分叉点，就是公共祖先

  <img align = 'left' src="img/3.11%E5%BC%80%E5%A7%8B%E7%9A%84%E9%A2%98.img/image-20210314170250414.png" alt="image-20210314170250414" style="zoom:50%;" />

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
    {
        //因为二叉搜索树左小右大，所以可以遍历该树，如果pq比结点值都大，则在右子树中继续
        //比结点值都小，在左子树中继续，如果pq一个比该节点大，一个比结点小，那么这就是分叉点，就是公共祖先
        while(root != nullptr)
        {
            if(p->val > root->val && q->val > root->val)
            {
                root = root->right;
            }
            else if(p->val < root->val && q->val < root->val)
            {
                root = root->left;
            }
            else
            {
                return root;
            }
        }
        return root;
    }
};
```





