# 寻找峰值I

山峰元素是指其值大于或等于左右相邻值的元素。给定一个输入数组nums，任意两个相邻元素值不相等，数组可能包含多个山峰。找到索引最大的那个山峰元素并返回其索引。

假设 nums[-1] = nums[n] = -∞。

```cpp
输入：[2,4,1,2,7,8,4]
返回值：5
```

**我的思路：**

- 要找下标最大的：从后往前找比前面大的元素，直接返回

```cpp
int solve(int* a, int aLen) {
    //从后往前遍历，找峰值
    if(a == NULL || aLen < 1){
        return -1;
    }

    for(int i = aLen-1; i > 0; --i){
        if(a[i] > a[i-1]){
            return i;
        }
    }
    return 0;
}
```

# 寻找峰值II

> 峰值元素是指其值大于左右相邻值的元素。
>
> 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。
>
> 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。
>
> 你可以假设 nums[-1] = nums[n] = -∞。
>
> 示例 1:
>
> 输入: nums = [1,2,3,1]
> 输出: 2
> 解释: 3 是峰值元素，你的函数应该返回其索引 2。
> 示例 2:
>
> 输入: nums = [1,2,1,3,5,6,4]
> 输出: 1 或 5 
> 解释: 你的函数可以返回索引 1，其峰值元素为 2；
>   或者返回索引 5， 其峰值元素为 6。

**我的思路：**：

- 二分查找，每次缩小查找空间，若mid比mid+1小，mid处于局部上坡，则峰值在右边，若mid比mid+1大，mid处于局部下坡，则峰值在左边

```c
int findPeakElement(vector<int>& nums) {
    int left = 0;
    int right = nums.size() - 1;

    while(left < right){
        int mid = left + (right - left)/2;

        if(nums[mid] < nums[mid+1]) left = mid + 1;
        else right = mid;    
    }
    return left;
}
```

# 旋转数组

一个数组A中存有N（N&gt0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M>=0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0 A1 ……AN-M-1 ）（最后M个数循环移至最前面的M个位置）。

```cpp
输入：6,2,[1,2,3,4,5,6]

返回值：[5,6,1,2,3,4]
```

**我的思路：**

- 先逆置整个数组，然后逆置0~m-1，再逆置m~size-1
- 123456 => 654321 => 56 1234

```cpp
class Solution {
public:
    vector<int> solve(int n, int m, vector<int>& vec) {
        //123456 => 654321
        //56  1234
        if(n > vec.size())    return vec;
        m = m % vec.size();  //如果m比size大的话，m取余数
        
        Reverse(vec, 0, n-1);  //654321
        Reverse(vec, 0, m-1);  //56
        Reverse(vec, m, n-1);  //1234
        return vec;
    }
    
    //逆置数组vec里i到j的元素
    void Reverse(vector<int> & vec, int i, int j)
    {
        for(; i < j; ++i, --j)    swap(vec[i], vec[j]);
    }
};
```

# 找到所有数组中消失的数字

```cpp
给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

输入: [4,3,2,7,8,2,3,1]

输出: [5,6]
```

**我的思路：**

- 把元素放在它应该放的位置（元素值为n，放在下标是n-1）
- 最后检查看哪一个下标放的元素不是下标+1

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) 
    {
        //把元素放在它应该放的位置
        //元素值为n，放在下标是n-1
        int size = nums.size();

        for(int i = 0; i < size;)
        {
            swap(nums[i], nums[nums[i]-1]);
            if(nums[i] == i+1 || nums[i] == nums[nums[i]-1])
            {
                i++;
            }
        }

        //最后检查看哪一个下标放的元素不是下标+1
        vector<int> rt;
        for(int i = 0; i < size; ++i)
        {
            if(nums[i] != i+1)
            {
                rt.push_back(i+1);
            }
        }
        return rt;
    }
};
```

