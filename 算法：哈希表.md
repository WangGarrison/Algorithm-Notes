# 设计哈希映射

```shell
不使用任何内建的哈希表库设计一个哈希映射（HashMap）。

实现 MyHashMap 类：
- MyHashMap() 用空映射初始化对象
- void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于  	映射中，则更新其对应的值 value 。
- int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。
- void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。
```

**我的思路：**

- 设计链式哈希表：不同的key计算的index相同的话，链在后面

  ![image-20210507110217699](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8.img/image-20210507110217699.png)

```cpp
class MyHashMap {
private:

    vector<list<pair<int, int>>> data;  //链式哈希表
    static const int base = 769;  //静态的目的：执行构造函数的时候该变量要已初始化，静态变量在主函数运行之前就已经初始化，const的静态变量可以在类内定义的时候直接赋值
    int hash(int key)//哈希函数
    {
        return key % base;
    }
public:
    MyHashMap():data(base) {}  //初始化哈希表
    
    //根据哈希函数算出来的index查找看key是否存在，存在的话就修改其value，不存在插入
    void put(int key, int value) 
    {
        int index = hash(key);
        for(auto it = data[index].begin(); it != data[index].end(); ++it)
        {
            if((*it).first == key)
            {
                (*it).second = value;
                return;
            }
        }
        data[index].push_back({key, value});
    }
    
    int get(int key) 
    {
        int index = hash(key);
        for(auto it = data[index].begin(); it != data[index].end(); ++it)
        {
            if((*it).first == key)
            {
                return (*it).second;
            }
        }
        return -1;
    }

    void remove(int key) 
    {
        int index = hash(key);
        for(auto it  = data[index].begin(); it != data[index].end(); ++it)
        {
            if((*it).first == key)
            {
                data[index].erase(it);
                return;
            }
        }
    }
};
```

