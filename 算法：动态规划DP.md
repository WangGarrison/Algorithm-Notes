> T61

# 目录

- [动规简介](#动规简介)

# 动规简介

> 动态规划（Dynamic programming，即DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，**通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。**
>
> 基本思想：若要解一个给定的问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。
>
> 通常许多子问题非常相似，==一旦某个给定的子问题的解已经算出，则将其记忆化存储==，以便下次需要同一个子问题解之时能直接查表。动态规划试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用
>
> 动态规划常常适用于==有重叠子问题和最优子结构==性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。
>
> 动态规划有自底向上和自顶向下两种解决问题的方式。
>
> - 自底向上：递推。
>
> - 自顶向下：记忆化递归
>
> 摘自：[Leetcode动态规划tag](https://leetcode-cn.com/tag/dynamic-programming/problemset/)

算法的基本思想与分治算法类似，也是将待求解问题分为若干子问题，按划分的顺序求解子阶段问题，前一个子问题的解，为后一子问题的求解提供了有用的信息（最优子结构）。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各个子问题，最后求出原问题的最优解

与分治算法最大的区别是：适合用于动态规划算法求解的问题，经分解后得到的**子问题往往不是互相独立**的

求解动归问题一般是求出状态与状态转移方程：

- 子问题的解 ==》状态
- 子问题的解怎么求出原问题的解 ==》状态转移方程

**动规所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。**

动规一般模式：初始状态 =》决策1=》决策2=》...决策n=》结束状态

- 找出问题最优解的性质，并刻画其结构特征（找问题状态）
- 递归地定义最优值（找状态转移方程）
- 自底向上地方式计算最优值
- 根据计算最优值时得到的信息，构造最优解

# 硬币选择问题

有1, 3, 5分面额的硬币，给定一个面值11，问组成给定面值所需要的最少的硬币数量是多少？

**解法一：分治算法**

![image-20210502103523206](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502103523206.png)

![image-20210502103553567](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502103553567.png)

**递归优化**

上述解法有一些子问题被重复求解了，==可以定义一个数组，存储每个子问题的结果（记忆化存储），再遇到相同的子问题时直接查表==

![image-20210502104937800](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502104937800.png)

**非递归解法**

![image-20210502113221018](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502113221018.png)

![image-20210502113938337](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502113938337.png)

# 斐波那契数列

0  1  1  2  3

```cpp
//迭代
int Fibonacci(int n) 
{
    //0 1 1 2
    //i j k
    int i = 0;
    int j = 1;
    if(n <= 1)    return n;
    int k = i + j;
    for(int m = 2; m <= n; ++m)
    {
        k = i + j;
        i = j;
        j = k;
    }
    return k;
}

//递归
int Fibonacci(int n)
{
    if(n <= 1)    return n;
    return Fibonacci(n-1) + Fibonacci(n-2);
}

//优化递归
int Fib(int n, int first, int second)  //调用n次Fib，每次更新first与second
{
    if(n <= 1)    return second;
    return Fib(n-1, second, first+second);
}
int Fibonacci(int n)
{
    if(n <= 1)    return n;
    return Fib(n, 0, 1);
}
```

**注意：施的数列是：1  1  2  3  ...**

![image-20210502120052528](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502120052528.png)

**递归（记忆化存储）**

![image-20210502120307892](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502120307892.png)

**非递归**

![image-20210502120617309](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502120617309.png)



# 最大子序和问题

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```cpp
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**我的思路：**

- 若当前元素之前的和小于0，则丢弃之前的和，重新计算和, 每次更新最大值

  ![image-20210502121606941](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502121606941.png)

```cpp
int maxSubArray(vector<int>& nums) 
{
    if(nums.empty())    return 0;

    int preSum = 0;
    int maxSum = nums[0];

    for(int i = 0; i < nums.size(); ++i)
    {
        if(preSum <= 0)
        { 
            preSum = nums[i];  //丢弃之前的和，重新计算和
        }
        else
        {
            preSum += nums[i];
        } 
        maxSum = max(preSum, maxSum);
    }
    return maxSum;
}
```

**注意：施的题目和上面的不完全一样**

![image-20210502123457078](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502123457078.png)

![image-20210502123213652](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502123213652.png)

# 最长升序子序列长度LIS问题

```shell
输入：5 3 4 1 8 7 9
输出：4 （3 4 8 9）
```

![image-20210502150057631](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502150057631.png)

![image-20210502145605741](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502145605741.png)

# 最长公共子序列LCS

LCS：longest common subsequence（注意，子序列可以不连续，子串要求连续）

![image-20210502152918743](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502152918743.png)

![image-20210502154716305](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502154716305.png)

![image-20210502153413434](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502153413434.png)

![image-20210502153444912](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502153444912.png)

**记忆化存储进行优化**

![image-20210502160313758](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502160313758.png)![image-20210502160509893](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP.img/image-20210502160509893.png)

# T70