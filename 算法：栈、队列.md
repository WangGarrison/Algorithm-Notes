# 最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

**我的思路：**

- 使用min_stack，保存每次元素入栈时对应的栈中最小元素，即记录当前为位置最小值

  <img align='left' src="img/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97.img/image-20210504154850664.png" alt="image-20210504154850664" style="zoom:50%;" />

```cpp
class MinStack {
private:
    stack<int> Stack;
    stack<int> Min_Stack;

public:
    MinStack() { Min_Stack.push(INT_MAX); }  //INT_MAX编译器的整型上限2^31-1 =2147483647
    
    void push(int x) 
    {
        Stack.push(x);
        Min_Stack.push(min(x, Min_Stack.top()));
    }
    
    void pop() 
    {
        Stack.pop();
        Min_Stack.pop();
    }
    
    int top()
    {
        return Stack.top();
    }
    
    int getMin() 
    {
        return Min_Stack.top();
    }
};
```

# 括号匹配

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

```c++
输入：s = "()[]{}"
输出：true
```

**我的思路：**

- 用map把右括号对应的左括号存起来
- 然后遍历字符串，借助栈，左括号入栈，右括号就判断栈顶是不是对应的左括号
- 最后要判断栈是否为空，不为空说明还有残留的左括号

```cpp
class Solution {
public:
    bool isValid(string s) 
    {
        int size = s.size();
        stack<char> sta;
        
        //把右括号对应的左括号存起来
        unordered_map<char, char> mp;
        mp.insert({')', '('});
        mp.insert({']', '['});
        mp.insert({'}', '{'});
        
        for(int i = 0; i < size; ++i)
        {
            if(s[i] == '[' || s[i] == '(' || s[i] == '{')
            {
                sta.push(s[i]);
            }
            else // ) ] }
            {
                if(sta.empty())    return false;
                
                char top = sta.top();    
                sta.pop();
                
                if(top != mp[s[i]])    return false;
            }
        }
        if(!sta.empty())    
        {
            return false;
        }
        return true;
    }
};
```

# 两个栈实现一个队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

**我的思路：**

- 定义两个栈，先进入第一个栈，然后出栈到第二个栈里面
- 入队列：将元素插入到第一个栈
- 出队列：如果栈2是空的，如果栈1也为空，返回-1，栈1不空，先把第一个栈里面的都放到第二个栈里面，再从第二个栈里面，弹出一个；如果栈2不是空的，直接从栈2弹出一个元素

```cpp
class CQueue {
private:
    stack<int> st1;
    stack<int> st2;
public:
    CQueue() {  }
    
    void appendTail(int value) 
    {
        st1.push(value);
    }
    
    int deleteHead() 
    {
        if(st2.empty())
        {
            if(st1.empty())
            {
                return -1;
            }
            while(!st1.empty())
            {
                st2.push(st1.top());
                st1.pop();
            }
        }
        int rt = st2.top();
        st2.pop();
        return rt;  
    }
};
```

## 