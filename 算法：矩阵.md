# 顺时针打印矩阵（螺旋打印）

```cpp
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**我的思路：**

- 从左到右，再从上到下，再从右到左，再从下到上（顺时针走一圈），每次走的时候要更新边界并且判断有没有结束
- <img align='left' src="img/3.11%E5%BC%80%E5%A7%8B%E7%9A%84%E9%A2%98.img/image-20210330225707407.png" alt="image-20210330225707407" style="zoom:53%;" />

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) 
    {
        //从左到右，再从上到下，再从右到左，再从下到上（顺时针走一圈），每次走的时候要更新边界
        vector<int> vec;
        if(matrix.empty())  return vec;

        int left = 0;
        int right = matrix[0].size()-1;
        int top = 0;
        int bottom = matrix.size()-1;

        while(left <= right && top <= bottom)
        {
            //左->右
            if(top > bottom) break;  //这个可以省略
            for(int i = left; i <= right; ++i)
            {
                vec.push_back(matrix[top][i]);
            }

            //上->下
            top++;
            if(left > right) break;  //这个可以省略
            for(int i = top; i <= bottom; ++i)
            {
                vec.push_back(matrix[i][right]);
            }

            //右->左
            right--;
            if(top > bottom) break;
            for(int i = right; i>= left; --i)
            {
                vec.push_back(matrix[bottom][i]);
            }

            //下->上
            bottom--;
            if(left > right) break;
            for(int i = bottom; i>= top; --i)//注意不是i>top，因为top加过了
            {
                vec.push_back(matrix[i][left]);
            }

            left++;
        }
        return vec;
    }
};
```

# 生成螺旋矩阵

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

```cpp
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
    
输入：n = 1
输出：[[1]]
```

**我的思路：**

- 先根据n初始化矩阵，然后从左到右，从上到下，再从右到左，再从下到上，顺时针遍历进行赋值
- 注意：用基于范围的for循环初始化二维数组的时候要==传引用==，否则初始化的是形参的

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) 
    {
        //先根据n初始化矩阵
        vector<vector<int>> matrix;
        matrix.resize(n);
        for(auto & vec : matrix)//注意这里一定要传引用，否则resize的是形参的
        {
            vec.resize(n);
        }

        //从左到右，从上到下，再从右到左，再从下到上，顺时针遍历进行赋值
        int left = 0;
        int right = n-1;
        int top = 0;
        int bottom = n-1;

        int num = 1;

        while(left <= right && top <= bottom)
        {
            //左->右
            if(top > bottom) break;
            for(int i = left; i <= right; ++i)
            {
                matrix[top][i] = num++;
            }

            //上->下
            top++;
            if(left > right) break;
            for(int i = top; i <= bottom; ++i)
            {
                matrix[i][right] = num++;
            }

            //右->左
            right--;
            if(top > bottom) break;
            for(int i = right; i >= left; --i)
            {
                matrix[bottom][i] = num++;
            }

            //下->上
            bottom--;
            if(left > right) break;
            for(int i = bottom; i >= top; --i)
            {
                matrix[i][left] = num++;
            }

            left++;
        }
        return matrix;
    }
};
```

# 矩阵旋转90度

```cpp
给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**我的思路1：**

- 原地交换：上下交换，再对角线交换

  ![image-20210512155923931](img/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%9F%A9%E9%98%B5.img/image-20210512155923931.png)

```cpp
void rotate(vector<vector<int>>& matrix) 
{
    if(matrix.size() <= 1)  return;

    //上下交换，再对角线交换
    int size = matrix.size();

    //上下交换
    for(int i = 0; i < size/2; ++i)
    {
        vector<int> tmp = matrix[i];
        matrix[i] = matrix[size-1-i];
        matrix[size-1-i] = tmp;
    }
    //对角线交换
    for(int i = 0; i < size; ++i)
    {
        for(int j = i + 1; j < size; ++j)
        {
            int tmp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = tmp;
        }
    }
}
```

**我的思路2：**

- 创建一个新矩阵，按旋转后的坐标挨个给新矩阵赋值

  <img align='left' src="img/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%9F%A9%E9%98%B5.img/image-20210512154009528.png" alt="image-20210512154009528" style="zoom:50%;" />

```cpp
void rotate(vector<vector<int>>& matrix) 
{
    if(matrix.size() <= 1)  return;

    vector<vector<int>> rota(matrix.size(), vector<int>(matrix[0].size()));
    int n = matrix.size();

    for(int i = 0; i < n; ++i)
    {
        for(int j = 0; j < n; ++j)
        {
            rota[i][j] = matrix[n-1-j][i];
        }
    }

    matrix = rota;
}
```

