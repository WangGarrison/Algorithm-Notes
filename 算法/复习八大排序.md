## 冒泡排序

- 遍历每次把大的交换后去
- O(n^2)   S(1)

```cpp
vector<int> sortArray(vector<int>& nums) 
{
    //冒泡排序：遍历每次把大的交换后去
    int size = nums.size();
    for(int i = 0; i < size - 1; ++i)  //注意这里交换size-1趟就可以了
    {
        for(int j = 0; j < size - i - 1; ++j)
        {
            if(nums[j] > nums[j+1])
            {
                int tmp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = tmp;
            }
        }
    }
    return nums;
}
```

## 选择排序

- 每次选择出最小的放在最前面
- O(n^2)   S(1)

```cpp
vector<int> sortArray(vector<int>& nums) 
{
    //选择排序：每次选择出最小的放在最前面
    int size = nums.size();

    for(int i = 0; i < size; ++i)
    {
        int minIndex = i;
        for(int j = i + 1; j < size; ++j)
        {
            if(nums[j] < nums[minIndex])
            {
                minIndex = j;
            }
        }
        int tmp = nums[i];
        nums[i] = nums[minIndex];
        nums[minIndex] = tmp;
    }
    return nums;
}
```

## 直接插入排序

- 每次将元素插入到左部分有序序列中（从后向前遍历找位置）
- 最坏O(n^2)，最好O(n)，S(1)
- 插入排序待排序数列越有序越快，完全有序时间复杂度为O(n)

```cpp
vector<int> sortArray(vector<int>& nums) 
{
    //直接插入排序：每次将元素插入到左部分有序序列中（从后向前遍历找位置）
    int size = nums.size();

    for(int i = 0; i < size; ++i)
    {
        int cur = nums[i]; //把cur插入到合适位置  124  3
        int j;
        for(j = i-1; j >= 0; --j)  //从后向前找左半部分的位置
        {
            if(nums[j] > cur)
            {
                nums[j + 1] = nums[j];
            }
            else
            {
                break;
            }
        }
        nums[j+1] = cur;
    }
    return nums;
}
```

## 希尔排序

- 带分组的插入排序
- 希尔排序与插入排序的不同之处在于，**它会通过设定带间隔的分组**，优先比较距离较远的元素（同时破坏了稳定性）
- O(n^1.3)   S(1)

```cpp
vector<int> sortArray(vector<int>& nums) 
{
    //希尔排序：带分组的插入排序
    vector<int> gaps = {5, 3, 1};  //增量分组
    for(int i = 0; i < gaps.size(); ++i)
    {
        sortArray(nums, gaps[i]);
    }
    return nums;
}

void sortArray(vector<int> & nums, int gap)
{
    int size = nums.size();
    for(int i = 0; i < size; ++i)
    {
        int cur = nums[i];
        int j;
        for(j = i-gap; j >= 0; j-=gap)
        {
            if(nums[j] > cur)
            {
                nums[j + gap] = nums[j];
            }
            else
            {
                break;
            }
        }
        nums[j+gap] = cur;
    }
}
```

## 快速排序

**递归快排**

- 一次划分把一个元素放到该放的位置
- 一次划分：从后往前找比基准小的放在前面，从前往后找比基准大的放在后面
- O(nlogn)，S(nlogn)

```cpp
vector<int> sortArray(vector<int>& nums)
{
    quickSort(nums, 0, nums.size()-1);
    return nums;
}

void quickSort(vector<int>& nums, int low, int high) 
{
    //快速排序：一次划分把一个元素放到该放的位置
    int mid = Partition(nums, low, high);
    if(mid-low > 1)
    {
        quickSort(nums, low, mid-1);
    }
    if(high-mid > 1)
    {
        quickSort(nums, mid+1, high);
    }
}

int Partition(vector<int> & nums, int low, int high)
{
    //随机选择基准，交换到第一个位置--------------
    int index = rand() % (high - low + 1) + low;
    int tmp = nums[low];
    nums[low] = nums[index];
    nums[index] = tmp;
    //-----------------------------------------
    int base = nums[low];


    while(low < high)
    {
        //从后往前找比基准小的放在前面
        while(low < high && nums[high] >= base)
        {
            high--;
        }
        if(low < high)
        {
            nums[low++] = nums[high];  //注意low++，low已经放好了下次就不用再比较它了
        }
        //从前往后找比基准大的放在后面
        while(low < high && nums[low] <= base)
        {
            low++;
        }
        if(low < high)
        {
            nums[high--] = nums[low];  //注意high--，high已经放好了下次就不用再比较它了
        }
    }
    nums[low] = base;
    return low;
}
```

**非递归快排**

```cpp
vector<int> sortArray(vector<int>& nums)
{
    quickSort(nums, 0, nums.size()-1);
    return nums;
}

void quickSort(vector<int>& nums, int low, int high) 
{
    //用栈来保存low与high的下标
    stack<int> sta;
    sta.push(low);
    sta.push(high);

    while(!sta.empty())
    {
        int right = sta.top();  sta.pop();
        int left = sta.top();   sta.pop();

        int mid = Partition(nums, left, right);
        if(mid - left > 1)
        {
            sta.push(left);
            sta.push(mid - 1);
        }
        if(right - mid > 1)
        {
            sta.push(mid +1);
            sta.push(right);
        }
    }
}

int Partition(vector<int> & nums, int low, int high)
{
    //随机选择基准，交换到第一个位置--------------
    int index = rand() % (high - low + 1) + low;
    int tmp = nums[low];
    nums[low] = nums[index];
    nums[index] = tmp;
    //-----------------------------------------
    int base = nums[low];


    while(low < high)
    {
        //从后往前找比基准小的放在前面
        while(low < high && nums[high] >= base)
        {
            high--;
        }
        if(low < high)
        {
            nums[low++] = nums[high];  //注意low++，low已经放好了下次就不用再比较它了
        }
        //从前往后找比基准大的放在后面
        while(low < high && nums[low] <= base)
        {
            low++;
        }
        if(low < high)
        {
            nums[high--] = nums[low];  //注意high--，high已经放好了下次就不用再比较它了
        }
    }
    nums[low] = base;
    return low;
}
```

