滑动窗口：在数组上通过双指针同向移动而解决的一类问题，（使用滑动窗口解决的问题通常是暴力解法的优化）

# 无重复字符的最长子串/最长不含重复字符的子字符串

```go
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**我的思路1：**

- 滑动窗口：遍历字符串，统计以每个字符作为左边界不重复子串的右边界，每次更新最大长度
- 使用map来记录该字符是否出现过，遍历完一个左边界，左边界加的时候得从map中删掉

```go
func lengthOfLongestSubstring(s string) int {
    //滑动窗口，遍历字符串，统计以每个字符作为左边界不重复子串的右边界，每次更新最大长度
    mp := map[byte]int{}
    len := len(s)
    maxlen := 0
    r := 0  //右边界

    for i := 0; i < len; i++ {
        //确定当前字符的右边界
        for j := r; j < len; j++ {
            if mp[s[j]] == 0 {  //不重复的字符
                mp[s[j]]++
                r++
            } else {
                break
            }
        }
        maxlen = max(r-i, maxlen)
        delete(mp, s[i])  //删除当前左边界
    }
    return maxlen
}

func max(a int, b int) int {
    if a > b {
        return a
    } else {
        return b
    }
}
```

**我的思路2：**

- 遍历字符串，用map记录字符--下标+1，遍历的时候记录当前不重复子串长度，每次更新最大长度，出现重复字符时，index不回溯，让curlen更新为正确的值（curlen = i+1 - map[s[i]]; ）
- 注意：如果遍历到重复字符，如果上一次的curlen < i+1-map[s[i]]，这一次的curlen就是上一次的curlen+1

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) 
    {
        //遍历字符串，用map记录字符--下标+1，遍历的时候记录当前不重复子串长度，每次更新最大长度
        int curlen = 0;
        int maxlen = 0;
        unordered_map<int, int> map;

        for(int i = 0; i < s.size(); ++i)
        {
            if(map[s[i]] == 0)  //之前没出现过
            {
                map[s[i]] = i + 1;
                curlen++;
            }
            else//之前出现过
            {
                if(curlen < i+1-map[s[i]]) curlen++;  //abba，遍历到尾部a的时候，不能用4-1，而是1+1
                else   curlen = i+1 - map[s[i]];          
                map[s[i]] = i + 1;
            }
            maxlen = max(curlen, maxlen);
        }
        return maxlen;
    }
};
```

**我的思路3：**

- 思路2未优化版本：遍历字符串，用map表记录字符下标+1，发生重复，回溯到重复字符的下一个位置

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string str) {
        // 遍历字符串，用map表记录字符下标+1，发生重复，回溯到重复字符的下一个位置
        unordered_map<char, int> map;

        int index = 0;
        int count = 0;
        int maxC = 0;
        while(index < str.size()) 
        {
            if(map[str[index]] == 0)
            {
                map[str[index]] = index+1 ;
                index++;
                count++;
            }
            else
            {
                index = map[str[index]];               
                maxC = max(count,maxC);
                map.clear();
                count = 0;
            }
        }
        maxC = max(count,maxC);
        return maxC;
    }
};
```

